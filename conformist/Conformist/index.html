<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Conformist (conformist.Conformist)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">conformist</a> &#x00BB; Conformist</nav><h1>Module <code>Conformist</code></h1><p>Conformist is a library for creating and validating schemas. It provides run-time types without using any ppx. It can be used to validate incoming data and to translate it to static types for safe usage.</p><nav class="toc"><ul><li><a href="#example">Example</a></li><li><a href="#fields">Fields</a></li><li><a href="#schema">Schema</a></li></ul></nav></header><section><header><h2 id="example"><a href="#example" class="anchor"></a>Example</h2><p>Let's start with an example. We have a static type that represents a user.</p><pre><code class="ml">type occupation =
  | Mathematician
  | Engineer

type user =
  { occupation : occupation
  ; email : string
  ; birthday : int * int * int
  ; nr_of_siblings : int
  ; comment : string option
  ; wants_premium : bool
  }</code></pre><p>In order to create a conformist schema, we need a constructor that takes all the record fields and create a <code>user</code>.</p><pre><code class="ml">let user occupation email birthday nr_of_siblings comment wants_premium =
  { occupation; email; birthday; nr_of_siblings; comment; wants_premium }
;;</code></pre><p>Now we can create a schema.</p><pre><code class="ml">let occupation_decoder = function
  | &quot;mathematician&quot; -&gt; Ok Mathematician
  | &quot;engineer&quot; -&gt; Ok Engineer
  | _ -&gt; Error &quot;Unknown occupation provided&quot;
;;

let occupation_encoder = function
  | Mathematician -&gt; &quot;mathematician&quot;
  | Engineer -&gt; &quot;engineer&quot;
;;

let user_schema =
  Conformist.(
    make
      Field.
        [ custom
            occupation_decoder
            occupation_encoder
            &quot;occupation&quot;
            ~meta:()
        ; string &quot;email&quot;
        ; date &quot;birthday&quot;
        ; int ~default:0 &quot;nr_of_siblings&quot;
        ; optional (string &quot;comment&quot;)
        ; bool &quot;wants_premium&quot;
        ]
      user)
;;</code></pre><p>Try to delete/swap lines of that list, to change the constructor or the <code>user</code> type. The code doesn't compile anymore!</p><p><code>user_schema</code> showcases the creation of a custom type and optional types.</p><p>This is how you can decode a user given some input:</p><pre><code class="ml">let user =
  let input =
    [ &quot;occupation&quot;, [ &quot;engineer&quot; ]
    ; &quot;email&quot;, [ &quot;test@example.com&quot; ]
    ; &quot;birthday&quot;, [ &quot;2020-12-01&quot; ]
    ; &quot;nr_of_siblings&quot;, [ &quot;3&quot; ]
    ; &quot;comment&quot;, [ &quot;hello&quot; ]
    ; &quot;wants_premium&quot;, [ &quot;true&quot; ]
    ]
  in
  Conformist.decode Schema.user_schema input
;;</code></pre><p>Decoding doesn't validate the data, it just makes sure that the types are correct and translates strings to the correct static types.</p><p>We can validate data based on each field's validators.</p><pre><code class="ml">let validation_errors =
  let input =
    [ &quot;occupation&quot;, [ &quot;engineer&quot; ]
    ; &quot;email&quot;, [ &quot;test@example.com&quot; ]
    ; &quot;birthday&quot;, [ &quot;2020-12-01&quot; ]
    ; &quot;nr_of_siblings&quot;, [ &quot;3&quot; ]
    ; &quot;comment&quot;, [ &quot;hello&quot; ]
    ; &quot;wants_premium&quot;, [ &quot;true&quot; ]
    ]
  in
  Conformist.validate Schema.user_schema input
;;</code></pre><p>Note that if decoding of a field fails, validation fails as well since before a field is validated it gets decoded.</p></header></section><section><header><h2 id="fields"><a href="#fields" class="anchor"></a>Fields</h2><p>Every member of the list in the example is a field. Use the provided <code>fold_left</code> to traverse the list of fiels. Helper functions are provided that operate on fields.</p></header><div class="spec module" id="module-Field"><a href="#module-Field" class="anchor"></a><code><span class="keyword">module</span> <a href="Field/index.html">Field</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-decoder"><a href="#type-decoder" class="anchor"></a><code><span class="keyword">type</span> <span>'a decoder</span></code><code> = string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, string)</span> Stdlib.result</span></code></dt><dd><p>A <code>'a decoder</code> tries to turn a string into a value of type <code>'a</code>. It returns a descriptive errors message upon failure.</p></dd></dl><dl><dt class="spec type" id="type-encoder"><a href="#type-encoder" class="anchor"></a><code><span class="keyword">type</span> <span>'a encoder</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> string</code></dt><dd><p>A <code>'a encoder</code> encodes a value of type <code>'a</code> into a string.</p></dd></dl><dl><dt class="spec type" id="type-validator"><a href="#type-validator" class="anchor"></a><code><span class="keyword">type</span> <span>'a validator</span></code><code> = <span class="type-var">'a</span> <span>&#45;&gt;</span> <span>string option</span></code></dt><dd><p>A <code>'a validator</code> takes something of type <code>'a</code> and returns an error string if validation fails, <code>None</code> if everything is ok</p></dd></dl><dl><dt class="spec value" id="val-custom"><a href="#val-custom" class="anchor"></a><code><span class="keyword">val</span> custom : <span><span class="type-var">'a</span> <a href="index.html#type-decoder">decoder</a></span> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="index.html#type-encoder">encoder</a></span> <span>&#45;&gt;</span> <span>?&#8288;default:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;type_:string</span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'b</span></span> <span>&#45;&gt;</span> <span>?&#8288;validator:<span><span class="type-var">'a</span> <a href="index.html#type-validator">validator</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'a</span>)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p>Use <code>custom decoder encoder ?default ?type_ ?meta ?validator field_name</code> to create a field with a custom type that is not supported out-of-the box. Provide a custom <code>decoder</code> with a descriptive error message so conformist knows how to turn a string into your custom value.</p><p>A string representation of the static <code>type_</code> can also be provided, by default the <code>field_name</code> is taken.</p><p>A <code>default</code> value can be provided.</p></dd></dl><dl><dt class="spec value" id="val-optional"><a href="#val-optional" class="anchor"></a><code><span class="keyword">val</span> optional : <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="Field/index.html#type-t">Field.t</a></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'c</span> option</span>)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>optional ?meta field</code> turns a <code>field</code> into an optional field. If the field does not exist in the input data or if the associated value in the input data is an empty list, the value is <code>None</code>. If the data is not provided in the input at all, no validation logic is executed.</p><p>Example:</p><pre><code class="ml">let make name address = { name; address } in
let schema =
  Conformist.(make [ string &quot;name&quot;; optional (string &quot;address&quot;) ] make)
in
(* Decoding fails *)
let decoded = Conformist.decode schema [] in
(* Validation fails *)
let validated = Conformist.validate [] in
(* Decoding succeeds, address is [None] *)
let decoded = Conformist.decode schema [ &quot;name&quot;, [ &quot;Walter&quot; ] ] in
let decoded =
  Conformist.decode schema [ &quot;name&quot;, [ &quot;Walter&quot; ]; &quot;address&quot;, [] ]
in
(* Validation succeeds *)
let validated = Conformist.validate [ &quot;name&quot;, [ &quot;Walter&quot; ] ] in
()</code></pre></dd></dl><dl><dt class="spec value" id="val-bool"><a href="#val-bool" class="anchor"></a><code><span class="keyword">val</span> bool : <span>?&#8288;default:bool</span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;msg:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, bool)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>bool ?default ?meta ?msg field_name</code> creates a field with <code>field_name</code> some <code>meta</code> data and a custom decode error message <code>msg</code> that decodes to a boolean.</p><p>A <code>default</code> value can be provided.</p></dd></dl><dl><dt class="spec value" id="val-float"><a href="#val-float" class="anchor"></a><code><span class="keyword">val</span> float : <span>?&#8288;default:float</span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;msg:string</span> <span>&#45;&gt;</span> <span>?&#8288;validator:<span>float <a href="index.html#type-validator">validator</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, float)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>float ?meta ?msg ?validator field_name</code> creates a field that decodes to a float with <code>field_name</code> some <code>meta</code> data, a custom decode error message <code>msg</code> and a <code>validator</code>.</p><p>A <code>default</code> value can be provided.</p></dd></dl><dl><dt class="spec value" id="val-int"><a href="#val-int" class="anchor"></a><code><span class="keyword">val</span> int : <span>?&#8288;default:int</span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;msg:string</span> <span>&#45;&gt;</span> <span>?&#8288;validator:<span>int <a href="index.html#type-validator">validator</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, int)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>int ?meta ?msg ?validator field_name</code> creates a field that decodes to an int with <code>field_name</code> some <code>meta</code> data, a custom decode error message <code>msg</code> and a <code>validator</code>.</p><p>A <code>default</code> value can be provided.</p></dd></dl><dl><dt class="spec value" id="val-string"><a href="#val-string" class="anchor"></a><code><span class="keyword">val</span> string : <span>?&#8288;default:string</span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;validator:<span>string <a href="index.html#type-validator">validator</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, string)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>string ?meta ?validator field_name</code> creates a field that decodes to a string with <code>field_name</code> some <code>meta</code> data and a <code>validator</code>. Note that this field does not need to be decoded, but it can still be validated.</p><p>A <code>default</code> value can be provided.</p></dd></dl><dl><dt class="spec type" id="type-date"><a href="#type-date" class="anchor"></a><code><span class="keyword">type</span> date</code><code> = int * int * int</code></dt><dd><p>Valid date example: 2020-11-25, this type is compatible with Ptime.date</p></dd></dl><dl><dt class="spec value" id="val-date"><a href="#val-date" class="anchor"></a><code><span class="keyword">val</span> date : <span>?&#8288;default:<a href="index.html#type-date">date</a></span> <span>&#45;&gt;</span> <span>?&#8288;meta:<span class="type-var">'a</span></span> <span>&#45;&gt;</span> <span>?&#8288;msg:string</span> <span>&#45;&gt;</span> <span>?&#8288;validator:<span><span>(int * int * int)</span> <a href="index.html#type-validator">validator</a></span></span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <a href="index.html#type-date">date</a>)</span> <a href="Field/index.html#type-t">Field.t</a></span></code></dt><dd><p><code>date ?meta ?validator field_name</code> creates a field that decodes to a date with <code>field_name</code> some <code>meta</code> data and a <code>validator</code>.</p><p>A <code>default</code> value can be provided.</p></dd></dl></section><section><header><h2 id="schema"><a href="#schema" class="anchor"></a>Schema</h2><p>A schema is a list of fields. Input data can be decoded and validated using a schema.</p></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> <span>('meta, 'ctor, 'ty) t</span></code></dt><dd><p><code>t</code> is a conformist schema.</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">val</span> empty : <span><span>(<span class="type-var">'a</span>, unit, unit)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>empty</code> creates an empty schema.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">val</span> make : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="Field/index.html#type-list">Field.list</a></span> <span>&#45;&gt;</span> <span class="type-var">'b</span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="index.html#type-t">t</a></span></code></dt><dd><p><code>make fields constructor</code> create a schema.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>f:<span>(<span class="type-var">'res</span> <span>&#45;&gt;</span> <span><span class="type-var">'meta</span> <a href="Field/index.html#type-any_field">Field.any_field</a></span> <span>&#45;&gt;</span> <span class="type-var">'res</span>)</span></span> <span>&#45;&gt;</span> <span>init:<span class="type-var">'res</span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'meta</span>, <span class="type-var">'args</span>, <span class="type-var">'ty</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <span class="type-var">'res</span></code></dt><dd><p><code>fold_left ~f ~init schema</code> traverses the list of fields of <code>schema</code>. Use the functions in <a href="Field/index.html"><code>Field</code></a> to work with a generic field.</p></dd></dl><dl><dt class="spec type" id="type-validation_error"><a href="#type-validation_error" class="anchor"></a><code><span class="keyword">type</span> validation_error</code><code> = <span><span>(string * string)</span> list</span></code></dt><dd><p>An empty <code>validation_error</code> means that the schema is valid.</p></dd></dl><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code><code> = <span><span>(string * <span>string list</span>)</span> list</span></code></dt><dd><p>The <code>input</code> represents unsafe data that needs to be decoded and validated. This is typically some user input.</p></dd></dl><dl><dt class="spec value" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span class="keyword">val</span> decode : <span><span>(<span class="type-var">'meta</span>, <span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'ty</span>, string * <span>string option</span> * string)</span> Stdlib.result</span></code></dt><dd><p><code>decode schema input</code> returns the decoded value of type <code>'ty</code> by decoding the <code>input</code> using the <code>schema</code>.</p><p>The returned error value is a triple <code>(field_name, input_value, error_msg)</code>. <code>field_name</code> is the field name of the input that failed to decode, <code>input_value</code> is the input value if one was provided and <code>error_msg</code> is the error message.</p><p>No validation logic is executed in this step.</p></dd></dl><dl><dt class="spec value" id="val-validate"><a href="#val-validate" class="anchor"></a><code><span class="keyword">val</span> validate : <span><span>(<span class="type-var">'meta</span>, <span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <a href="index.html#type-validation_error">validation_error</a></code></dt><dd><p><code>validate schema input</code> returns a list of validation errors by running the validators defined in <code>schema</code> on the <code>input</code> data. An empty list implies that there are no validation errors and that the input is valid according to the schema.</p><p>Note that <code>input</code> that has no validation errors might still fail to decode, depending on the validation functions specified in <code>schema</code>.</p></dd></dl><dl><dt class="spec value" id="val-decode_and_validate"><a href="#val-decode_and_validate" class="anchor"></a><code><span class="keyword">val</span> decode_and_validate : <span><span>(<span class="type-var">'meta</span>, <span class="type-var">'ctor</span>, <span class="type-var">'ty</span>)</span> <a href="index.html#type-t">t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-input">input</a> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'ty</span>, <a href="index.html#type-validation_error">validation_error</a>)</span> Stdlib.Result.t</span></code></dt><dd><p><code>decode_and_validate schema input</code> returns the decoded and validated value of type <code>'ty</code> by decoding the <code>input</code> using the <code>schema</code> and running its validators.</p><p>The returned error is a <a href="index.html#type-validation_error"><code>validation_error</code></a>. If a field fails to decode, the error of that field is the decode error. If a field decodes but fails to validate, then the error is the validation error.</p><p>Use <code>decode_and_validate</code> to combine the functions <code>decode</code> and <code>validate</code> and to either end up with the decoded value or all errors that happened during the decoding and validation steps.</p></dd></dl></section></div></body></html>